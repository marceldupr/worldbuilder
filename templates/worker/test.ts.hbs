import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { Queue, Worker } from 'bullmq';
import Redis from 'ioredis';

/**
 * Unit Tests for {{name}} Worker
 * Generated by Worldbuilder
 * 
 * {{#if description}}{{description}}{{/if}}
 */

describe('{{pascalCase name}} Worker', () => {
  let connection: Redis;
  let queue: Queue;
  let worker: Worker;

  beforeEach(async () => {
    connection = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      maxRetriesPerRequest: null,
    });

    queue = new Queue('{{queue}}', { connection });
    
    // Clean up queue before each test
    await queue.obliterate({ force: true });
  });

  afterEach(async () => {
    if (worker) {
      await worker.close();
    }
    if (queue) {
      await queue.close();
    }
    if (connection) {
      await connection.quit();
    }
  });

  describe('Job Processing', () => {
    it('should process job successfully', async () => {
      const testData = {
        // Test job data
        id: 'test-id',
        data: { test: true },
      };

      const job = await queue.add('test-job', testData);
      
      expect(job.id).toBeDefined();
      expect(job.data).toEqual(testData);
    });

    it('should handle job with progress updates', async () => {
      const testData = { id: 'test-id' };
      const progressUpdates: number[] = [];

      const job = await queue.add('test-job', testData);
      
      job.updateProgress = async (progress: number) => {
        progressUpdates.push(progress);
      };

      // Worker should update progress through the job steps
      expect(progressUpdates.length).toBeGreaterThan(0);
    });

{{#if steps}}
{{#each steps}}
    it('should execute step: {{name}}', async () => {
      const testData = {
        // Data for {{name}} step
      };

      const job = await queue.add('{{../queue}}', testData);
      
      // Verify step execution
      // TODO: Add specific assertions for {{name}}
      expect(job).toBeDefined();
    });

{{/each}}
{{/if}}

    it('should retry failed jobs', async () => {
      const testData = { shouldFail: true };

      const job = await queue.add('test-job', testData, {
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 1000,
        },
      });

      expect(job.opts?.attempts).toBe(3);
    });

    it('should handle job timeout', async () => {
      const testData = { id: 'test-id' };

      const job = await queue.add('test-job', testData, {
        timeout: 5000,
      });

      expect(job.opts?.timeout).toBe(5000);
    });
  });

  describe('Error Handling', () => {
    it('should handle missing data', async () => {
      const job = await queue.add('test-job', {});
      
      // Worker should handle missing data gracefully
      expect(job).toBeDefined();
    });

    it('should log failed jobs', async () => {
      const testData = { forceError: true };

      const job = await queue.add('test-job', testData);
      
      // Verify error logging
      expect(job).toBeDefined();
    });
  });
});

