{{#each helpers}}
import { {{pascalCase name}}Helper } from '../helpers/{{kebabCase name}}.helper.js';
{{/each}}

/**
 * {{name}} Worker
 * {{description}}
 * 
 * Supports two modes:
 * 1. Queue Mode (with Redis) - for production with BullMQ
 * 2. Direct Mode (no Redis) - for development or simple deployments
 */

// Check if Redis is available
const USE_QUEUE = process.env.USE_QUEUE === 'true' && 
                  process.env.REDIS_HOST && 
                  process.env.REDIS_PORT;

// Lazy import for optional dependencies
let Worker: any, Job: any, Queue: any, Redis: any;
let connection: any;
let worker: any;

if (USE_QUEUE) {
  try {
    const bullmq = await import('bullmq');
    Worker = bullmq.Worker;
    Job = bullmq.Job;
    Queue = bullmq.Queue;
    
    const ioredis = await import('ioredis');
    Redis = ioredis.default;
    
    connection = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      maxRetriesPerRequest: null,
    });
    
    console.log(`‚úì Redis connected - Queue mode enabled for {{name}}`);
  } catch (error) {
    console.warn('‚ö†Ô∏è Redis not available - falling back to direct mode');
    USE_QUEUE = false;
  }
}

{{#each helpers}}
const {{camelCase name}}Helper = new {{pascalCase name}}Helper();
{{/each}}

// Job data interface
export interface {{pascalCase name}}JobData {
  [key: string]: any;
}

// Job processor
async function processJob(job: Job<{{pascalCase name}}JobData>): Promise<any> {
  console.log(`Processing job ${job.id} in queue {{queue}}`);
  
  try {
    const { data } = job;
    
{{#each steps}}
    // Step {{add @index 1}}: {{name}}
    await job.updateProgress({{multiply @index (divide 100 (add ../steps.length 1))}});
    console.log('Step {{add @index 1}}/{{../steps.length}}: {{name}}...');
    
{{#if helperId}}
    // Call helper: {{../helpers.[helperId].name}}
    try {
      await {{camelCase ../helpers.[helperId].name}}Helper.{{camelCase action}}(data);
      console.log('  ‚úì {{name}} completed');
    } catch (error) {
      console.error('  ‚úó {{name}} failed:', error);
      throw error;
    }
{{else if elementId}}
    // Update element: {{../elements.[elementId].name}}
    try {
      const {{camelCase ../elements.[elementId].name}}Service = await import('../services/{{kebabCase ../elements.[elementId].name}}.service.js');
      await {{camelCase ../elements.[elementId].name}}Service.{{camelCase action}}(data);
      console.log('  ‚úì {{name}} completed');
    } catch (error) {
      console.error('  ‚úó {{name}} failed:', error);
      throw error;
    }
{{else}}
    // Custom step: {{name}}
    // {{description}}
    try {
      // Implement custom logic here based on step description
      console.log('  ‚ö† Step "{{name}}" needs custom implementation');
      console.log('  Description: {{description}}');
      
      // For now, mark as completed
      console.log('  ‚úì {{name}} completed (custom implementation needed)');
    } catch (error) {
      console.error('  ‚úó {{name}} failed:', error);
      throw error;
    }
{{/if}}
    
{{/each}}
    
    await job.updateProgress(100);
    console.log(`Job ${job.id} completed successfully`);
    
    return { success: true };
  } catch (error) {
    console.error(`Job ${job.id} failed:`, error);
    throw error;
  }
}

/**
 * Execute job directly (without queue)
 * Used when Redis is not available
 */
export async function executeDirect(data: {{pascalCase name}}JobData): Promise<any> {
  console.log(`[Direct] Executing {{name}} job`);
  
  const mockJob = {
    id: `direct-${Date.now()}`,
    data,
    updateProgress: async (progress: number) => {
      console.log(`[Direct] Progress: ${progress}%`);
    },
  };
  
  return await processJob(mockJob as any);
}

// Initialize based on mode
if (USE_QUEUE) {
  // Create BullMQ worker
  worker = new Worker('{{queue}}', processJob, {
    connection,
    concurrency: {{concurrency}},
    limiter: {
      max: {{concurrency}},
      duration: 1000,
    },
  });

  // Event handlers
  worker.on('completed', (job: any) => {
    console.log(`‚úì Job ${job.id} completed`);
  });

  worker.on('failed', (job: any, err: Error) => {
    console.error(`‚úó Job ${job?.id} failed:`, err);
  });

  worker.on('error', (err: Error) => {
    console.error('Worker error:', err);
  });

  console.log(`üöÄ {{name}} worker started (queue: {{queue}}, concurrency: {{concurrency}})`);
  
  export default worker;
} else {
  // Direct mode - export the executor function
  console.log(`üöÄ {{name}} worker started (direct mode - no queue)`);
  
  // Export a mock worker interface for compatibility
  export default {
    name: '{{name}}',
    mode: 'direct',
    execute: executeDirect,
  };
}

