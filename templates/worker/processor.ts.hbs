import { Worker, Job } from 'bullmq';
import Redis from 'ioredis';
{{#each helpers}}
import { {{pascalCase name}}Helper } from '../helpers/{{kebabCase name}}.helper.js';
{{/each}}

/**
 * {{name}} Worker
 * {{description}}
 */

const connection = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  maxRetriesPerRequest: null,
});

{{#each helpers}}
const {{camelCase name}}Helper = new {{pascalCase name}}Helper();
{{/each}}

// Job data interface
interface {{pascalCase name}}JobData {
  [key: string]: any;
}

// Job processor
async function processJob(job: Job<{{pascalCase name}}JobData>): Promise<any> {
  console.log(`Processing job ${job.id} in queue {{queue}}`);
  
  try {
    const { data } = job;
    
{{#each steps}}
    // Step {{add @index 1}}: {{name}}
    await job.updateProgress({{multiply @index (divide 100 (add ../steps.length 1))}});
    console.log('Step {{add @index 1}}/{{../steps.length}}: {{name}}...');
    
{{#if helperId}}
    // Call helper: {{../helpers.[helperId].name}}
    try {
      await {{camelCase ../helpers.[helperId].name}}Helper.{{camelCase action}}(data);
      console.log('  âœ“ {{name}} completed');
    } catch (error) {
      console.error('  âœ— {{name}} failed:', error);
      throw error;
    }
{{else if elementId}}
    // Update element: {{../elements.[elementId].name}}
    try {
      const {{camelCase ../elements.[elementId].name}}Service = await import('../services/{{kebabCase ../elements.[elementId].name}}.service.js');
      await {{camelCase ../elements.[elementId].name}}Service.{{camelCase action}}(data);
      console.log('  âœ“ {{name}} completed');
    } catch (error) {
      console.error('  âœ— {{name}} failed:', error);
      throw error;
    }
{{else}}
    // Custom step: {{name}}
    // {{description}}
    try {
      // Implement custom logic here based on step description
      console.log('  âš  Step "{{name}}" needs custom implementation');
      console.log('  Description: {{description}}');
      
      // For now, mark as completed
      console.log('  âœ“ {{name}} completed (custom implementation needed)');
    } catch (error) {
      console.error('  âœ— {{name}} failed:', error);
      throw error;
    }
{{/if}}
    
{{/each}}
    
    await job.updateProgress(100);
    console.log(`Job ${job.id} completed successfully`);
    
    return { success: true };
  } catch (error) {
    console.error(`Job ${job.id} failed:`, error);
    throw error;
  }
}

// Create worker
const worker = new Worker('{{queue}}', processJob, {
  connection,
  concurrency: {{concurrency}},
  limiter: {
    max: {{concurrency}},
    duration: 1000,
  },
});

// Event handlers
worker.on('completed', (job) => {
  console.log(`âœ“ Job ${job.id} completed`);
});

worker.on('failed', (job, err) => {
  console.error(`âœ— Job ${job?.id} failed:`, err);
});

worker.on('error', (err) => {
  console.error('Worker error:', err);
});

console.log(`ðŸš€ {{name}} worker started (queue: {{queue}}, concurrency: {{concurrency}})`);

export default worker;

