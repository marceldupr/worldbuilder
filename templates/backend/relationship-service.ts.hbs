/**
 * Relationship-aware service extensions
 * Generated by Worldbuilder
 */

import { PrismaClient } from '@prisma/client';

// This extends the basic services with relationship loading
export class RelationshipLoader {
  constructor(private prisma: PrismaClient) {}

  /**
   * Get includes object for Prisma queries based on relationships
   */
  getIncludes(elementName: string): any {
    const includes: any = {};
    
    {{#each relationships}}
    {{#if (eq from ../elementName)}}
    // {{type}} relationship to {{to}}
    {{#if (eq type "belongsTo")}}
    includes.{{camelCase fieldName}} = true;
    {{else if (eq type "hasOne")}}
    includes.{{camelCase fieldName}} = true;
    {{else if (eq type "hasMany")}}
    includes.{{camelCase fieldName}} = {
      take: 10, // Limit to avoid loading too much data
    };
    {{else if (eq type "manyToMany")}}
    includes.{{camelCase fieldName}} = {
      take: 10,
    };
    {{/if}}
    {{/if}}
    {{/each}}
    
    return includes;
  }

  /**
   * Format related data for display
   */
  formatRelatedData(entity: any, relationships: any[]): any {
    const formatted = { ...entity };
    
    relationships.forEach((rel: any) => {
      const fieldName = rel.fieldName;
      if (formatted[fieldName]) {
        // Add display name for related entity
        formatted[`${fieldName}_display`] = this.getDisplayName(formatted[fieldName], rel.to);
      }
    });
    
    return formatted;
  }

  /**
   * Get display name for an entity (uses common fields like 'name', 'title', etc.)
   */
  private getDisplayName(entity: any, entityType: string): string {
    if (!entity) return 'N/A';
    
    // Try common name fields
    const nameFields = ['name', 'title', 'label', 'displayName', 'fullName', 'email', 'username'];
    for (const field of nameFields) {
      if (entity[field]) return entity[field];
    }
    
    // Fallback to ID
    return entity.id || 'Unknown';
  }
}

