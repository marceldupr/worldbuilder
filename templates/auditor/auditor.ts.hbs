import { PrismaClient } from '@prisma/client';

/**
 * {{name}} - Audit Trail & Validation
 * {{description}}
 */

interface AuditLogData {
  entityType: string;
  entityId: string;
  action: string;
  userId: string;
  before: any;
  after: any;
  metadata?: any;
}

export class {{pascalCase name}} {
  constructor(private prisma: PrismaClient) {}

  /**
   * Validation before creating {{linkedElement}}
   */
  async beforeCreate(data: any): Promise<void> {
{{#if enableValidation}}
    // Validation rules for {{linkedElement}}
    {{#each rules}}
    {{#if (eq trigger 'before_create')}}
    // Rule: {{description}}
    {{#each validations}}
    {{#if (eq condition 'required')}}
    if (!data.{{field}}) {
      throw new Error('{{errorMessage}}');
    }
    {{else if (eq condition 'unique')}}
    const existing = await this.prisma.{{camelCase ../../linkedElement}}.findFirst({
      where: { {{field}}: data.{{field}} }
    });
    if (existing) {
      throw new Error('{{errorMessage}}');
    }
    {{else if (eq condition 'min_length')}}
    if (data.{{field}} && data.{{field}}.length < {{value}}) {
      throw new Error('{{errorMessage}}');
    }
    {{else if (eq condition 'max_length')}}
    if (data.{{field}} && data.{{field}}.length > {{value}}) {
      throw new Error('{{errorMessage}}');
    }
    {{else if (eq condition 'min_value')}}
    if (data.{{field}} !== undefined && data.{{field}} < {{value}}) {
      throw new Error('{{errorMessage}}');
    }
    {{else if (eq condition 'max_value')}}
    if (data.{{field}} !== undefined && data.{{field}} > {{value}}) {
      throw new Error('{{errorMessage}}');
    }
    {{else if (eq condition 'pattern')}}
    if (data.{{field}} && !{{value}}.test(data.{{field}})) {
      throw new Error('{{errorMessage}}');
    }
    {{else}}
    // Custom validation: {{condition}}
    // {{errorMessage}}
    {{/if}}
    {{/each}}
    {{/if}}
    {{/each}}
{{else}}
    // No validation rules defined
{{/if}}
  }

  /**
   * Audit log after creating {{linkedElement}}
   */
  async afterCreate(entity: any, userId: string): Promise<void> {
{{#if (or (includes auditEvents 'created') (includes auditEvents 'all'))}}
    await this.createAuditLog({
      entityType: '{{linkedElement}}',
      entityId: entity.id,
      action: 'CREATE',
      userId,
      before: null,
      after: entity,
    });
{{/if}}
  }

  /**
   * Validation before updating {{linkedElement}}
   */
  async beforeUpdate(existing: any, updates: any): Promise<void> {
{{#if enableValidation}}
    // Validation rules for updates
    {{#each rules}}
    {{#if (eq trigger 'before_update')}}
    // Rule: {{description}}
    {{#each validations}}
    {{#if (eq condition 'immutable')}}
    if (updates.{{field}} !== undefined && updates.{{field}} !== existing.{{field}}) {
      throw new Error('{{errorMessage}}');
    }
    {{else if (eq condition 'unique')}}
    if (updates.{{field}}) {
      const duplicate = await this.prisma.{{camelCase ../../linkedElement}}.findFirst({
        where: { 
          {{field}}: updates.{{field}},
          id: { not: existing.id }
        }
      });
      if (duplicate) {
        throw new Error('{{errorMessage}}');
      }
    }
    {{else}}
    // Use same validation as beforeCreate
    {{/if}}
    {{/each}}
    {{/if}}
    {{/each}}
{{else}}
    // No validation rules defined
{{/if}}
  }

  /**
   * Audit log after updating {{linkedElement}}
   */
  async afterUpdate(before: any, after: any, userId: string): Promise<void> {
{{#if (or (includes auditEvents 'updated') (includes auditEvents 'all'))}}
    await this.createAuditLog({
      entityType: '{{linkedElement}}',
      entityId: after.id,
      action: 'UPDATE',
      userId,
      before,
      after,
    });
{{/if}}
  }

  /**
   * Validation before deleting {{linkedElement}}
   */
  async beforeDelete(entity: any): Promise<void> {
    // Custom business rules can be added here
  }

  /**
   * Audit log after deleting {{linkedElement}}
   */
  async afterDelete(entity: any, userId: string): Promise<void> {
{{#if (or (includes auditEvents 'deleted') (includes auditEvents 'all'))}}
    await this.createAuditLog({
      entityType: '{{linkedElement}}',
      entityId: entity.id,
      action: 'DELETE',
      userId,
      before: entity,
      after: null,
    });
{{/if}}
  }

  /**
   * Create audit log entry
   */
  private async createAuditLog(data: AuditLogData): Promise<void> {
    await this.prisma.auditLog.create({
      data: {
        ...data,
        timestamp: new Date(),
      },
    });
  }

  /**
   * Query audit logs
   */
  async getAuditLogs(entityId: string): Promise<any[]> {
    return await this.prisma.auditLog.findMany({
      where: {
        entityType: '{{linkedElement}}',
        entityId,
      },
      orderBy: { timestamp: 'desc' },
    });
  }
}

