/**
 * {{name}} - Workflow Orchestrator
 * {{description}}
 */

interface WorkflowContext {
  userId?: string;
  data: any;
  results: Map<string, any>;
  errors: Error[];
}

interface WorkflowStep {
  name: string;
  execute: (context: WorkflowContext) => Promise<any>;
  onError?: 'retry' | 'skip' | 'abort';
  timeout?: number;
}

export class {{pascalCase name}} {
  private steps: WorkflowStep[] = [];

  constructor(
    // Inject dependencies here
    private dependencies: any = {}
  ) {
    this.initializeSteps();
  }

  /**
   * Initialize workflow steps
   */
  private initializeSteps(): void {
{{#each steps}}
    // Step {{add @index 1}}: {{name}}
    this.steps.push({
      name: '{{name}}',
      execute: this.execute{{pascalCase name}}.bind(this),
      onError: '{{onError}}' || 'abort',
      timeout: {{timeout}} || 30000,
    });

{{/each}}
  }

{{#each steps}}
  /**
   * Step {{add @index 1}}: {{description}}
   {{#if component}}
   * Component: {{component}}
   * Action: {{action}}
   {{/if}}
   */
  private async execute{{pascalCase name}}(context: WorkflowContext): Promise<any> {
    try {
      {{#if component}}
      // Call {{component}}.{{action}}
      const result = await this.call{{pascalCase component}}{{pascalCase action}}(context);
      {{else}}
      // Custom step: {{name}}
      // {{description}}
      console.log('‚ö† Step "{{name}}" - custom implementation needed');
      console.log('  Context:', context.data);
      
      // Return success for now - implement actual logic here
      const result = { 
        success: true, 
        step: '{{name}}',
        message: 'Custom step logic needs implementation'
      };
      {{/if}}

      context.results.set('{{name}}', result);
      return result;
    } catch (error) {
      console.error('Error in step {{name}}:', error);
      context.errors.push(error as Error);
      throw error;
    }
  }

{{/each}}

  /**
   * Execute the complete workflow
   */
  async execute(input: any, userId?: string): Promise<{
    success: boolean;
    results: any;
    errors: Error[];
  }> {
    const context: WorkflowContext = {
      userId,
      data: input,
      results: new Map(),
      errors: [],
    };

    console.log('üîÑ Starting workflow: {{name}}');

    for (const [index, step] of this.steps.entries()) {
      try {
        console.log(`  Step ${index + 1}/${this.steps.length}: ${step.name}`);
        
        const timeoutPromise = step.timeout
          ? new Promise((_, reject) =>
              setTimeout(() => reject(new Error(`Step ${step.name} timed out`)), step.timeout)
            )
          : null;

        const result = timeoutPromise
          ? await Promise.race([step.execute(context), timeoutPromise])
          : await step.execute(context);

        console.log(`  ‚úÖ ${step.name} completed`);
      } catch (error) {
        console.error(`  ‚ùå ${step.name} failed:`, error);
        
        if (step.onError === 'skip') {
          console.log(`  ‚è≠Ô∏è  Skipping ${step.name} and continuing`);
          continue;
        } else if (step.onError === 'retry') {
          console.log(`  üîÑ Retrying ${step.name}...`);
          try {
            await step.execute(context);
            console.log(`  ‚úÖ ${step.name} succeeded on retry`);
          } catch (retryError) {
            console.error(`  ‚ùå ${step.name} failed on retry`);
            return {
              success: false,
              results: Object.fromEntries(context.results),
              errors: context.errors,
            };
          }
        } else {
          // abort
          console.log(`  üõë Aborting workflow`);
          return {
            success: false,
            results: Object.fromEntries(context.results),
            errors: context.errors,
          };
        }
      }
    }

    console.log('‚úÖ Workflow completed successfully');
    return {
      success: true,
      results: Object.fromEntries(context.results),
      errors: context.errors,
    };
  }

  /**
   * Rollback the workflow (if supported)
   */
  async rollback(context: WorkflowContext): Promise<void> {
    console.log('üîô Rolling back workflow...');
    
    // Rollback steps in reverse order
    const completedSteps = Array.from(context.results.keys()).reverse();
    
    for (const stepName of completedSteps) {
      try {
        console.log(`  Reverting step: ${stepName}`);
        // Add step-specific rollback logic here
        // For now, just log
      } catch (error) {
        console.error(`  Failed to rollback ${stepName}:`, error);
      }
    }
    
    console.log('üîô Rollback completed');
  }

{{#each steps}}
{{#if component}}
  /**
   * Helper: Call {{component}}.{{action}}
   */
  private async call{{pascalCase component}}{{pascalCase action}}(context: WorkflowContext): Promise<any> {
    {{#if (eq componentType 'element')}}
    // Import and call element service
    const { {{camelCase component}}Service } = await import('../services/{{kebabCase component}}.service.js');
    return await {{camelCase component}}Service.{{camelCase action}}(context.data);
    {{else if (eq componentType 'helper')}}
    // Import and call helper
    const { {{pascalCase component}}Helper } = await import('../helpers/{{kebabCase component}}.helper.js');
    const helper = new {{pascalCase component}}Helper();
    return await helper.{{camelCase action}}(context.data);
    {{else if (eq componentType 'worker')}}
    // Queue worker job
    const { {{camelCase component}}Queue } = await import('../queues/{{kebabCase component}}.queue.js');
    const job = await {{camelCase component}}Queue.add('{{action}}', context.data);
    return { jobId: job.id, queued: true };
    {{else}}
    // Generic component call
    const {{camelCase component}} = this.dependencies.{{camelCase component}};
    if (!{{camelCase component}}) {
      throw new Error('Component {{component}} not found in dependencies');
    }
    return await {{camelCase component}}.{{camelCase action}}(context.data);
    {{/if}}
  }

{{/if}}
{{/each}}
}

