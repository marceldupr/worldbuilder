import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { {{pascalCase name}} } from '../{{kebabCase name}}.workflow';

/**
 * Unit Tests for {{pascalCase name}} Workflow
 * Generated by Worldbuilder
 * 
 * {{#if description}}{{description}}{{/if}}
 */

describe('{{pascalCase name}} Workflow', () => {
  let workflow: {{pascalCase name}};
  let mockDependencies: any;

  beforeEach(() => {
    // Mock dependencies
    mockDependencies = {
{{#each steps}}
{{#if component}}
      {{camelCase component}}: {
        {{camelCase action}}: async (data: any) => ({ success: true, data }),
      },
{{/if}}
{{/each}}
    };

    workflow = new {{pascalCase name}}(mockDependencies);
  });

  describe('Workflow Execution', () => {
    it('should execute complete workflow successfully', async () => {
      const input = {
        // Test workflow input
        test: true,
      };

      const result = await workflow.execute(input, 'test-user-id');

      expect(result.success).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should track results from each step', async () => {
      const input = { test: true };

      const result = await workflow.execute(input);

      expect(result.results).toBeDefined();
      expect(typeof result.results).toBe('object');
    });

{{#each steps}}
    it('should execute step: {{name}}', async () => {
      const input = {
        // Test data for {{name}}
      };

      const result = await workflow.execute(input);

      expect(result.results['{{name}}']).toBeDefined();
    });

{{/each}}
  });

  describe('Error Handling', () => {
    it('should handle step failure with abort', async () => {
      mockDependencies = {
        failingStep: {
          action: async () => {
            throw new Error('Simulated failure');
          },
        },
      };

      workflow = new {{pascalCase name}}(mockDependencies);
      const input = { test: true };

      const result = await workflow.execute(input);

      expect(result.success).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });

    it('should handle step timeout', async () => {
      mockDependencies = {
        slowStep: {
          action: async () => {
            await new Promise(resolve => setTimeout(resolve, 60000));
            return { success: true };
          },
        },
      };

      workflow = new {{pascalCase name}}(mockDependencies);
      const input = { test: true };

      // Should timeout before 60 seconds
      const result = await workflow.execute(input);
      
      expect(result).toBeDefined();
    });
  });

  describe('Rollback', () => {
    it('should rollback on workflow failure', async () => {
      const input = { test: true };
      const context = {
        userId: 'test-user',
        data: input,
        results: new Map([['step1', { success: true }]]),
        errors: [],
      };

      await workflow.rollback(context);

      // Verify rollback executed
      expect(context).toBeDefined();
    });
  });

  describe('Context Management', () => {
    it('should maintain context across steps', async () => {
      const input = {
        initialValue: 'test',
      };

      const result = await workflow.execute(input);

      expect(result.success).toBe(true);
      expect(Object.keys(result.results).length).toBeGreaterThan(0);
    });
  });
});

