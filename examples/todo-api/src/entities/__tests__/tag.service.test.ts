import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { PrismaClient } from '@prisma/client';
import { TagService } from '../tag.service';
import { CreateTagDto, UpdateTagDto } from '../tag.entity';

/**
 * Unit Tests for Tag Service
 * Generated by Worldbuilder
 * 
 * 
 */

describe('Tag Service', () => {
  let prisma: PrismaClient;
  let service: TagService;
  const testUserId = 'test-user-id';

  beforeEach(async () => {
    prisma = new PrismaClient();
    service = new TagService(prisma);
    
    // Clean up test data
    await prisma.tag.deleteMany({});
  });

  afterEach(async () => {
    await prisma.$disconnect();
  });

  describe('create', () => {
    it('should create tag with valid data', async () => {
      const createDto: CreateTagDto = {
        name: 'Test Name',
        color: 'Test Color',
      };

      const result = await service.create(createDto, testUserId);

      expect(result.id).toBeDefined();
      expect(result.name).toBe(createDto.name);
      expect(result.color).toBe(createDto.color);
    });

    it('should reject missing name', async () => {
      const invalidDto: any = {
        name: 'Test',
        color: 'Test',
      };

      await expect(
        service.create(invalidDto, testUserId)
      ).rejects.toThrow();
    });

  });

  describe('findById', () => {
    it('should find existing tag', async () => {
      const created = await service.create({
        name: 'Test Name',
        color: 'Test Color',
      }, testUserId);

      const found = await service.findById(created.id);

      expect(found).not.toBeNull();
      expect(found?.id).toBe(created.id);
    });

    it('should return null for non-existent tag', async () => {
      const found = await service.findById('non-existent-id');
      expect(found).toBeNull();
    });
  });

  describe('update', () => {
    it('should update tag', async () => {
      const created = await service.create({
        name: 'Original',
        color: 'Original',
      }, testUserId);

      const updateDto: UpdateTagDto = {
      };

      const updated = await service.update(created.id, updateDto, testUserId);

    });

    it('should throw error for non-existent tag', async () => {
      await expect(
        service.update('non-existent-id', {}, testUserId)
      ).rejects.toThrow('Tag not found');
    });
  });

  describe('delete', () => {
    it('should delete tag', async () => {
      const created = await service.create({
        name: 'Test',
        color: 'Test',
      }, testUserId);

      await service.delete(created.id, testUserId);

      const found = await service.findById(created.id);
      expect(found).toBeNull();
    });

    it('should throw error for non-existent tag', async () => {
      await expect(
        service.delete('non-existent-id', testUserId)
      ).rejects.toThrow('Tag not found');
    });
  });

  describe('findAll', () => {
    it('should return empty array when no tags exist', async () => {
      const result = await service.findAll({});
      expect(result).toHaveLength(0);
    });

    it('should return all tags', async () => {
      await service.create({
        name: 'Test 1',
        color: 'Test 1',
      }, testUserId);

      await service.create({
        name: 'Test 2',
        color: 'Test 2',
      }, testUserId);

      const result = await service.findAll({});
      expect(result).toHaveLength(2);
    });
  });
});

